### 12.1 子类化内置类型很麻烦* 直接子类化内置类型（如dict，list，str）容易出错，因此内置类i系那个的方法通常会忽略用户覆盖的方法，不要子类化内置类型，用户自定义的类应该继承collections模块中的类，UserDict，UserList，UserString，这些类做了特殊的设计，因此，易于扩展。### 12.2 多重继承和方法解析顺序* python能区分d.pong（）调用的是哪个方法，是因为python会按照特定的顺序遍历继承图，这个顺序叫方法解析顺序，类都有一个名为 `__mro__`的属性，它的值是一个元组，按照方法解析顺序列出各个超类，从当前类一直向上，直到object。```def pint(self):    A.ping(self)    # 如果类继承了多个类，A是其中之一    print(self)```* 注意，直接在类上调用实例方法时，必须显示传入self参数，因为这样访问的是未绑定方法。* 然而，使用super最安全。### 12.4 处理多重继承* 下面是避免把类图搅乱的一些建议。1. 把接口继承和实现继承区分开来：使用多继承时，一定要明确一开始为什么创建子类，主要原因可能是：    1. 继承接口，创建子类型，实现“是什么”的关系。    2. 继承实现，通过重用避免代码重复。 2. 使用抽象基类显示表示接口：现代的python中，如果类的作用是定义接口，应该明确把它定义为抽象基类3. 通过混入重用代码：如果一个类的作用是为多个不相关的子类提供方法实现，从而实现重用，但不体现“是什么”关系，应该把那个类明确的定义为混入类，从概念上讲，混入不定义新类型，只是打包方法，便于重用，混入类绝对不能实例化，而且具体类不能只继承混入类，混入类应该提供某方面的特定行为，只实现少量关系非常紧密的方法。4. 把名称中明确指明混入：因为在python中没有把类声明为混入的正规方法，所以强烈推荐的名称中加入 ...Mixin后缀，5. 抽象基类可以作为混入，反过来则不成立：抽象基类可以实现具体方法，因此可以作为混入使用，不过，抽象基类会定义类型，而混入做不到，此为，抽象基类可以作为其他类型的唯一基类，而混入绝不能作为唯一的超类。6. 不要子类化多个具体类：具体类可以没有，或者最多只有一个超类，也就是说，具体类的超类中除了这个具体超类之外，其余都是抽象基类或者混入，例如下面代码，如果Alpha是具体类，那么Beta和Gamma必须是抽象基类或者混入。```class MyConcreteClass(Alpha, Beta, Gamma):```7. 为用户提供聚合类：如果抽象基类或混入的组合对客户代码非常有用，那就提供一个类，使用易于理解的方法把他们结合起来，```class Widget(BaseWidget, Pack, Place, Grid):    pass```8. 优先使用对象组合，而不是类继承：这句话引自《设计模式:可复用面向对象软件的基础》，### 本章小结* 内置类型的原生方法使用c语言实现，不会调用子类中覆盖的方法，不过有极少例外，因此，需要定义list，dict或str类型时，子类化UserList，UserDict，UserString。### 杂谈* 想想哪些类是真正需要的：大多数程序元编写应用程序而不是开发框架，即便是开发框架的那些人，多数时候也是编写应用程序，编写应用程序时，我们通常不用设计类的层次结构，我们之多会编写子类，继承抽象基类或框架提供的其他类。如果作为应用程序开发者，你发现自己在构建多层次结构。可能发生下面的事情：1. 你在重新发明轮子。去找框架或库，他们提供的组件可以在应用程序中重用。2. 你是用的框架设计不良，去寻找替代品。3. 你在过度设计。记住要遵循KISS原则。4. 你厌烦了编写应用程序，决定新造一个新的框架。