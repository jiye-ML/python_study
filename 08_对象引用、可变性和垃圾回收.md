* 本章的主题是对象与对象名称之间的区别，名称不是对象，而是单独的东西。    * 变量是标注，而不是盒子。* 本章会揭露元组的一个神奇特性：元组是不可变的，但其中的值可以改变。* 引申到浅复制和深复制* 引用和函数参数：可变的参数默认值导致问题，一起如何安全处理函数调用者传入的可变参数。* 垃圾回收、del命令、以及如何时候用弱引用‘记住’对象，而不需对象本身存在。### 8.1 变量不是盒子* 对引用变量来说，说把变量分配给对象更合理，反过来就有问题，比较，对象在赋值之前就创建了。#### 8.2 表示、相等性和别名#### is 和 == 之间选择* ==比较两个对象的值（保存在对象中的数据），is比较对象的标识。#### 元组的相对不可变性### 8.3 默认做浅复制* 复制列表，最简单的方法是使用内置的类型构造方法。* 不可变对象复制会重新申请对象，然后标识。### 8.4 函数的参数作为引用时* python唯一支持的参数传递模式是共享传参。* 共享传参是指函数的各个形式参数获得参数中各个引用的副本。也就是说，函数内部的形参是实参的别名。#### 不要使用可变类型作为参数的默认值* 可选参数可以有默认值，这是python函数定义的一个很棒的特性，这样我们的API向后兼容，但我们应该回避使用可变对象的默认值。```>>> bus1 = HauntedBus(['Alice', 'Bill'])>>> bus1.passengers['Alice', 'Bill']>>> bus1.pick('Charlie')>>> bus1.drop('Alice')>>> bus1.passengers ['Bill', 'Charlie']>>> bus2 = HauntedBus() >>> bus2.pick('Carrie')>>> bus2.passengers['Carrie']>>> bus3 = HauntedBus() >>> bus3.passengers ['Carrie']>>> bus3.pick('Dave')>>> bus2.passengers ['Carrie', 'Dave']>>> bus2.passengers is bus3.passengers True>>> bus1.passengers ['Bill', 'Charlie']```* bus3和bus2的passengers指代了同一个列表出。* 出现这个问题的根源是，默认值在定义函数是计算（通常加载模块时），因此如果默认值是可变对象，而且修改它的值，那么后续的函数调用都会收到影响。* 可以审查 `HauntedBus.__init__`对象，看看它的`__defaults__`属性中的那些幽灵学生。```>>> dir(HauntedBus.__init__) # doctest: +ELLIPSIS['__annotations__', '__call__', ..., '__defaults__', ...]>>> HauntedBus.__init__.__defaults__(['Carrie', 'Dave'],)```* 我们验证bus2.passengers是一个别名，它绑定到`HauntedBus.__init__.__defaults__`属性的第一个元素上```>>> HauntedBus.__init__.__defaults__[0] is bus2.passengersTrue```#### 防御可变参数* 设计接口的最佳实践，最少惊讶原则* 除非这个方法确实想改变通过参数传入的对象，否则在类中直接把参数赋值给实例变量之前一定要三思，因为这样会为参数对象创建别名，如果不确定，那就创建副本。### 8.5 del和垃圾回收* del语句删除名称，而不是对象，del命令可能会导致对象被当做垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时，重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。### 8.6 弱引用* 正是因为引用，对象才会在内存中存在，当对象的引用数量归零后，垃圾回收程序会把对象销毁，但是，有时候需要引用对象，而不让对象存在的时间超过所需要的时间，这经常用在缓存中。* 弱引用不会增加对象的引用数量，引用的目标对象是所指对象，因此我们说，弱引用不会妨碍所指对象被当做垃圾回收。#### WeakValueDictionary简介* WeakValueDictionary类实现的是一种可变映射，里面的值是对象的弱引用，被引用的对象在程序中其他地方被当做垃圾回后，对应的键会自动从WeakValueDictionary中删除。因此，WeakValueDictionary经常用于缓存。#### WeakKayDictionary* 可以为应用中其他部分拥有的对象附加数据，这样就无需为对象添加属性，这对覆盖属性访问权限的对象尤为有用。* weakref模块提供了WeakSet类，按照文档说明，这个类的作用很简单，保存元素弱引用的集合类。元素没有强引用时，集合会把它删除，如果一个类需要知道所有实例，一种好的方案是创建一个WeakSet类型的属性，保存所有实例引用，如果使用常规的set，实例永远不会被垃圾回收。#### 弱引用的局限* 不是每个python对象都可以作为弱引用的目标，基本的list和dict实例就不能，但他们的子类可以。* set可以作为所指对象* 用户定义的类型可以作为所指对象* int 和 tuple实例不能作为弱引用的目标，甚至子类也不行。### 杂谈* python采取了正确的方法，==运算符比较对象的值，is比较引用，* python支持重载运算符，==能正确处理标准库中的所有对象，None也是一个正常对象。* 你可以定义 `__eq__`方法，决定==的行为，如果没有覆盖，那么默认的object继承方法比较对象id，因此每个后备机制认为用户定义的类各个实例不同。