## 核心模块

### 1 介绍

1. 内建函数和异常： 这两个模块比其他模块加在一起还要重要，
    * 定义内建函数（len,int, range）的 `__builtin__`模块。
    * 定义内建异常的 `exceptions`模块。
    
2. 操作系统接口模块： 有许多使用POSIX标准API和标准c语言库的模块，它们的低层操作系统提供了平台独立的接口。
* 提供文件和进程处理功能的os模块，
* 提供平台独立的文件处理（分拆目录名，文件名，后缀等）的os.path模块；
* 时间日期处理相关的 time/datetime模块

3. 类型支持的模块
* string模块实现了常用的字符串处理，
* math模块提供了数学计算操作和常量(pi,e都属于这类常量)
* cmath模块为复数提供和math一样的功能

4. 正则表达式
  * re模块为python提供了正则表达式支持，
5. 语言支持模块：
* sys模块可以让你访问解释器相关的参数，比如模块的搜索路径，解释器版本号
* operator模块提供了和内建操作符作用相同的函数
* copy模块允许你复制对象


### 2 `__buitin__`模块

* python允许你实时创建函数参数列表，只要把所有参数加入一个元组中，然后通过内建的apply函数调用函数
```
def function(a, b):
    print a, b
apply(function, ('whither', 'canada?'))
apply(function, ('cruchy'), {'b': 'frog'})
apply(function, (), {'a': 'cruchy', b': 'frog'})
```
* apply函数的一个常见用法是把构造函数参数从子类传递给基类，尤其是构造函数需要接受很多参数的时候。
```python
class Rectangle:
    def __init__(self, color='white', width=10, height=10):
        print a
class RoundedRectangle(Rectangle):
    def __init__(self, **kw):
        apply(Rectangle.__init__, (self), kw)
```

#### 2.1 加载和重载模块
> 用来导入外部模块的import语句是靠调用内建函数 `__import__`来工作的。
通过这种戏法你可以动态地调用函数，当你只知道模块名称的时候，浙江很方便

* [import使用代码](temp/core/study_import.py)


#### 2.2 关于名称空间

* [namespace 代码](temp/core/study_namespace.py)

#### 2.4 检查对象类型

* Python 是一种动态类型语言, 这意味着给一个定变量名可以在不同的场合绑定
  到不同的类型上. 在接下面例子中, 同样的函数分别被整数, 浮点数, 以及一
  个字符串调用: 
* 注意类对象都是可调用的，如果调用它们，就产生一个新的对象，但是A的实例不能调用，因为类没有实现 __call__ 方法;
* 在处理类和实例的时候会复杂，python不会把类作为本质上的类型对待，相反，所有类都属于一个特殊的类类型，所有的实例都属于特殊的实例类型这意味着你不能使用type函数来测试一个实例是否属于一个给定的类，所有的实例都是同样的类型。
* 这意味着你不能使用 type 函数来测试一个实例是否属于一个给定的类; 所有
  的实例都是同样的类型! 为了解决这个问题, 你可以使用 isinstance 函数,它
  会检查一个对象是不是给定类(或其子类)的实例. 

* [type 代码](temp/core/study_type.py)

#### 2.5 计算python表达式

* python提供了在程序中与解释器交互的多种方法，例如eval函数将一个字符串作为python表达式求值，
* [python表达式](temp/core/study_python表达式.py)

#### 2.6 编译和执行代码

* eval 函数只针对简单的表达式. 如果要处理大块的代码, 你应该使用 compile
  和 exec 函数 ；



### 3. exceptions 模块 

* exceptions 模块提供了标准异常的层次结构. Python 启动的时候会自动导入
  这个模块, 并且将它加入到 _ _builtin_ _ 模块中. 也就是说, 一般不需要手
  动导入这个模块. 
* 该模块定义了以下标准异常: 
  * Exception 是所有异常的基类. 强烈建议(但不是必须)自定义的异常异
    常也继承这个类. 
  * SystemExit(Exception) 由 sys.exit 函数引发. 如果它在最顶层没有
    被 try-except 语句捕获, 那么解释器将直接关闭而不会显示任何跟踪
    返回信息. 
  * StandardError(Exception) 是所有内建异常的基类(除 SystemExit
    外). 
  * KeyboardInterrupt(StandardError) 在用户按下 Control-C(或其他打
    断按键)后 被引发. 如果它可能会在你使用 "捕获所有" 的 try-except
    语句时导致奇怪的问题. 
  * ImportError(StandardError) 在 Python 导入模块失败时被引发.
  * EnvironmentError 作为所有解释器环境引发异常的基类. (也就是说,
    这些异常一般不是由于程序 bug 引起).
  * IOError(EnvironmentError) 用于标记 I/O 相关错误.
  *  OSError(EnvironmentError) 用于标记 os 模块引起的错误.
  * WindowsError(OSError) 用于标记 os 模块中 Windows 相关错误.
  * NameError(StandardError) 在 Python 查找全局或局部名称失败时被引
    发.
  * UnboundLocalError(NameError) , 当一个局部变量还没有赋值就被使用
    时, 会引发这个异常. 这个异常只有在 2.0 及之后的版本有; 早期版本
    只会引发一个普通的 NameError .
  * AttributeError(StandardError) , 当 Python 寻找(或赋值)给一个实
    例属性, 方法, 模块功能或其它有效的命名失败时, 会引发这个异常.
  * SyntaxError(StandardError) , 当解释器在编译时遇到语法错误, 这个
    异常就被引发.
  * IndentationError(SyntaxError) 在遇到非法的缩进时被引发. 该异常只用于 2.0 及以后版本, 之前版本会引发一个SyntaxError 异常.
  * TabError(IndentationError) , 当使用 -tt 选项检查不一致缩进时有可能被引发. 该异常只用于 2.0 及以后版本, 之前版本会引发一个 SyntaxError 异常.
  * TypeError(StandardError) , 当给定类型的对象不支持一个操作时被引
    发.
  * AssertionError(StandardError) 在 assert 语句失败时被引发(即表达
    式为 false 时).
  * LookupError(StandardError) 作为序列或字典没有包含给定索引或键时
    所引发异常的基类.
  * IndexError(LookupError) , 当序列对象使用给定索引数索引失败时(不
    存在索引对应对象)引发该异常.
  * KeyError(LookupError) 当字典对象使用给定索引索引失败时(不存在索
    引对应对象)引发该异常.
  * ArithmeticError(StandardError) 作为数学计算相关异常的基类
  * OverflowError(ArithmeticError) 在操作溢出时被引发(例如当一个整
    数太大, 导致不能符合给定类型).
  * ZeroDivisionError(ArithmeticError) , 当你尝试用 0 除某个数时被引发.
  * FloatingPointError(ArithmeticError) , 当浮点数操作失败时被引发.
  * ValueError(StandardError) , 当一个参数类型正确但值不合法时被引发.
  *  UnicodeError(ValueError) , Unicode 字符串类型相关异常. 只使用在 2.0 及以后版本.
  * RuntimeError(StandardError) , 当出现运行时问题时引发, 包括在限制模式下尝试访问外部内容, 未知的硬件问题等等.
  * NotImplementedError(RuntimeError) , 用于标记未实现的函数, 或无
    效的方法。
  * SystemError(StandardError) , 解释器内部错误. 该异常值会包含更多的细节 (经常会是一些深层次的东西, 比如 "eval_code2: NULL globals" ) . 这本书的作者编了 5 年程序都没见过这个错误. (想必是没有用 raise SystemError ).
  * MemoryError(StandardError) , 当解释器耗尽内存时会引发该异常. 注意只有在底层内存分配抱怨时这个异常才会发生; 如果是在你的旧机器上, 这个异常发生之前系统会陷入混乱的内存交换中。



### 4. os 模块 

#### 4.1 处理文件 

* 内建的 open / file 函数用于创建, 打开和编辑文件, 而 os 模块提供了重命名和删除文件所需的函数
* [os_拷贝文件_调整两个文件的状态信息](temp/os_拷贝文件_调整两个文件的状态信息.py)
* [os_拷贝文件_过程中替换某些内容](temp/os_拷贝文件_过程中替换某些内容.py)

#### 4.2 处理目录

* os 模块也包含了一些用于目录处理的函数.listdir 函数返回给定目录中所有文件名(包括目录名)组成的列表;

* [os_访问目录下的所有文件](temp/os_访问目录下的所有文件.py)
* [os_删除和创建文件（夹）](temp/os_删除和创建文件（夹）.py)

#### 4.3 处理文件属性 

* stat 函数可以用来获取一个存在文件的信息, 它返回一个类元组对象(stat_result 对象, 包含 10 个元素), 依次是 
  1. st_mode (权限模式),
  2.  st_ino (inode number), 
  3. st_dev (device),
  4. st_nlink (number of hardlinks), 
  5. st_uid (所有者用户 ID), 
  6. st_gid (所有者所在组 ID ),
  7.  st_size (文件大小, 字节), 
  8. st_atime (最近一次访问时间), 
  9. st_mtime (最近修改时间),
  10. st_ctime (平台相关; Unix 下的最近一次元数据metadata 修改时间, 或者Windows 下的创建时间) - 以上项目也可作为属性访问. 

* [os_当前文件路径](temp/os_当前文件路径.py)
* [os_获得文件的状态信息](temp/os_获得文件的状态信息.py)

#### 4.4 处理进程 

* system 函数在当前进程下执行一个新命令, 并等待它完成,
* [os_执行操作系统命令](temp/os_exec_执行操作系统命令.py)
* [os_调用其他程序](temp/os_exec_调用其他程序.py)
* [os_exec_启动新进程](temp/os_exec_启动新进程.py)
* [os_spawn_调用其他程序](temp/os_spawn_调用其他程序.py)
* [os_spawn_调用其他程序_不同平台都可以](temp/os_spawn_调用其他程序_不同平台都可以.py)
* [os_spawn_调用其他程序_后台运行](temp/os_spawn_调用其他程序_后台运行.py)

#### 4.5 处理守护进程(Daemon Processes) 

* Unix 系统中, 你可以使用 fork 函数把当前进程转入后台(一个"守护者/daemon"). 一般来说, 你需要派生(fork off)一个当前进程的副本, 然后终止原进程。

* 需要创建一个真正的后台程序稍微有点复杂, 

  1. 调用 setpgrp 函数创建一个"进程组首领/process group leader". 否则, 向无关进程组发送的信号(同时)会引起守护进程的问题:  `os.setpgrp() `

  2. 为了确保守护进程创建的文件能够获得程序指定的 mode flags(权限模式标记?), 最好删除 user mode mask: `os.umask(0) `

  3. 然后, 你应该重定向 stdout/stderr 文件, 而不能只是简单地关闭它们(如果你的程序需要 stdout 或 stderr 写入内容的时候, 可能会出现意想不到的问题) 

     ```python
     class NullDevice:
         def write(self, s):
             pass
         
     sys.stdin.close()
     sys.stdout = NullDevice()
     sys.stderr = NullDevice()
     ```

* 换言之, 由于 Python 的 print 和 C 中的 printf/fprintf 在设备(device)没有连接后不会关闭你的程序, 此时守护进程中的 sys.stdout.write() 会抛出一个 IOError 异常, 而你的程序依然在后台运行的很好。

* [os_使脚本作为守护执行(unix)](temp/os_使脚本作为守护执行(unix).py)

* [os_终止当前进程](temp/os_终止当前进程.py)

### 5 os.path 模块 

* os.path 模块包含了各种处理长文件名(路径名)的函数. 先导入 (import) os
  模块, 然后就可以以 os.path 访问该模块. 

#### 搜索文件系统 

* walk 函数会帮你找出一个目录树下的所有文件。它的参数依次是目录名, 回调函数, 以及传递给回调函数的数据对象。

### 6 stat模块

### 7 string 模块 

string 模块提供了一些用于处理字符串类型的函数, 

### 8 re 模块 

* re 模块提供了一系列功能强大的正则表达式 (regular expression) 工具, 它
  们允许你快速检查给定字符串是否与给定的模式匹配 (使用 match 函数), 或
  者包含这个模式 (使用 search 函数). 正则表达式是以紧凑(也很神秘)的语法
  写出的字符串模式。
*  match 尝试从字符串的起始匹配一个模式. 如果模式匹配了某些内容 (包括空字符串, 如果模式允许的话) , 它将返回一个匹配对象. 使用它的 group 方法可以找出匹配的内容. 

### 9. math 模块

### 11. operator

* operator 模块为 Python 提供了一个 "功能性" 的标准操作符接口. 当使用map 以及 filter 一类的函数的时候, operator 模块中的函数可以替换一些lambda 函式. 而且这些函数在一些喜欢写晦涩代码的程序员中很流行.

### 12. copy 模块

* copy 模块包含两个函数, 用来拷贝对象, copy(object) => object 创建给定对象的 "浅/浅层(shallow)" 拷贝(copy).这里 "浅/浅层(shallow)" 的意思是复制对象本身, 但当对象是一个容器(container) 时, 它的成员仍然指向原来的成员对象 。

### 13. sys 模块

* 在解释器启动后, argv 列表包含了传递给脚本的所有参数, 如 Example 1-66
  所示. 列表的第一个元素为脚本自身的名称。
* [sys_argv_包含了传递给脚本的所有参数](temp/sys_argv_包含了传递给脚本的所有参数.py)
* [sys_builtin_module_names_查找内建模块](temp/sys_builtin_module_names_查找内建模块)
* [sys_exit_退出程序](temp/sys_exit_退出程序)
* [sys_getrefcount_返回给定对象的引用记数](temp/sys_getrefcount_返回给定对象的引用记数)
* [sys_modules_查找已导入的模块](temp/sys_modules_查找已导入的模块)
* [sys_path_操作模块搜索路径](temp/sys_path_操作模块搜索路径)
* [sys_platform_获得当前平台](temp/sys_platform_获得当前平台)
* [sys_setprofiler_配置一个分析函数](temp/sys_setprofiler_配置一个分析函数)
* [sys_settrace_配置单步跟踪函数](temp/sys_settrace_配置单步跟踪函数)
* [sys_stdout_输出重定向](temp/sys_stdout_输出重定向)

### 14. atexit 模块 

* atexit 模块允许你注册一个或多个终止函数, 这些函数将在解释器终止前被自动调用.
  调用 register 函数, 便可以将函数注册为终止函数,你也可以添加更多的参数, 这些将作为 exit 函数的参数传递. 

* [atexit_注册一个或者多个终止函数](temp/atexit_注册一个或者多个终止函数)

### 15. time 模块 

* time 模块提供了一些处理日期和一天内时间的函数. 
* 它是建立在 C 运行时库的简单封装.
* 给定的日期和时间可以被表示为浮点型(从参考时间, 通常是 1970.1.1 到现在经过的秒数. 即 Unix 格式), 或者一个表示时间的 struct (类元组) 
* [CoreTime](temp/demo/CoreTime.py)

### 16. types 模块 

* [types_判断输入的类型](temp/types_判断输入的类型.py)

### 17 gc 垃圾收集模块