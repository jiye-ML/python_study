* 字典为动词“to yield”给出了两个释义：产出和让步。对于python生成器中的yield类来说，这两个含义都成立：    * yield item产出一个值，提供给next调用方    * 做出让步，暂停执行生成器，让调用方继续工作，直到需要使用另一个值时再调用next，调用方会从生成器中拉取值。* 从句法上看，协程与生成器类似，都是定义体包含yield关键字的函数，可是，在协程中，yield通常出现在表达式的右边，可以产出值，也可以不产出值，如果yield关键字后面没有表达式，那么生成器产出None，协程可能会从调用方接受数据，不过调用方把数据提供给协程使用的是.send(datum)方法，而不是next函数，通常，调用方会把值直接推送给协程。* yield关键字甚至还可以不接收或传出数据。不管数据如何流动，yield都是一种流程控制工具，使用它可以实现协作式多任务：协程可以把控制器让步给中心调度程序，从而激活其他的协程。> 从根本上把yield视作控制流程方式，这样就好理解协程了。* 本章内容：1. 生成器视作协程使用时的行为和状态；2. 使用装饰器自动预激协程3. 调用方如何使用协程的send 和 close，throw方法控制协程4. 协程终止时如何返回值5. yield from新句法的用途和语义6. 使用案例： 使用协程管理仿真系统中的并发活动### 16.1 生成器如何进化成协程* 可以使用send()方法发送数据，发送的数据会成为生成器函数中yield表达式的值，因此，生成器可以视作协程使用。协程是指一个过程，这个过程与调用方写作，产出由调用方提供的值```>>> def simple_coroutine(): # ➊    ... print('-> coroutine started')    ... x = yield # ➋  yield在表达式中使用，如果协程只需要从客户端那里接收数据，    ... print('-> coroutine received:', x)...>>> my_coro = simple_coroutine()>>> my_coro # ➌与创建生成器方法一样， 调用函数得到生成器对象<generator object simple_coroutine at 0x100c2be10>>>> next(my_coro) # ➍首先调用next函数，因为生成器函数还没有启动，没在yield语句处暂停，所以一开始无法发送数据。-> coroutine started>>> my_coro.send(42) # ➎-> coroutine received: 42Traceback (most recent call last): # ➏...StopIteration```* 协程可以身处四个状态中的一个，当前状态可以使用inspect.getgeneratorstate()函数确定。    * GEN_CREATED: 等待开始执行    * GEN_RUNNING 解释器正在执行    * GEN_SUSPENDED：在yield表达式处暂停    * GEN_CLOSE：执行结束* 因为send方法的参数会成为暂停yield表达式的值，所以，仅当协程处于暂停状态时才能调用send方法。不过协程还没有激活，情况就不同了，因此，始终要调用next(my_coro)激活协程，也可以调用my_coro.send(None)，效果一样。* 关键的一点是，协程在yield关键字所在的位置暂停执行。前面说过，在赋值语句中，=右边的diamante在赋值之前执行。因此b = yield a这行代码来说。等到客户端代码再激活协程时才会设定b的值，这种行为要花点时间才能习惯，不过一定要理解，这样才能弄懂异步编程中yield的作用。### 16.3 示例：使用协程计算移动平均值```def averager():    total = 0.0    count = 0    average = None    while True:        term = yield average        total += term        count += 1        average = total / count``````>>> coro_avg = averager() ➊>>> next(coro_avg) ➋>>> coro_avg.send(10) ➌10.0>>> coro_avg.send(30)20.0>>> coro_avg.send(5)15.0```### 16.4 预激协程的装饰器* 调用函数只是得到生成器对象，需要next（）才能执行yield语句，然后等待接收传入数据。### 16.5 终止协程和异常处理* `generator.throw(exec_type[, exec_value[, traceback]])`:致使生成器在暂停的yield表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，而产生的值会成为调用generator.throw方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。* `generator.close()`： 致使生成器在暂停的yield表达式处抛出GeneratorExit异常。如果生成器没有处理这个异常，或者抛出了StopIteration异常，调用方不会报错。如果收到GeneratorExit异常，生成器一定不能产出值，否则解释器会抛出RuntimeError异常。生成器抛出的其它异常会向上冒泡，传递给调用方。### 16.6 让协程返回值### 16.7 使用yield from* yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常，而不是在位于中间的协程中添加大量处理异常的样本代码。* 委派生成器： 包含yield from <iterable>表达式的生成函数。* 子生成器：从yield from表达式中<iterable>部分获取的生成器* 调用方![](16_协程/yield_from.png)```from collections import namedtupleResult = namedtuple('Result', 'count average')# 子生成器def averager(): ➊    total = 0.0    count = 0    average = None    while True:        term = yield ➋        if term is None: ➌        break        total += term        count += 1        average = total/count    return Result(count, average) ➍    # 委派生成器def grouper(results, key): ➎    while True: ➏        results[key] = yield from averager() ➐# 客户端代码， 即调用方def main(data): ➑    results = {}    for key, values in data.items():        group = grouper(results, key) ➒        next(group) ➓        for value in values:        group.send(value) ⓫        group.send(None) # 重要！ ⓬    # print(results) # 如果要调试， 去掉注释    report(results)    # 输出报告def report(results):    for key, result in sorted(results.items()):        group, unit = key.split(';')        print('{:2} {:5} averaging {:.2f}{}'.format(result.count, group, result.average, unit))data = {'girls;kg':[40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5],'girls;m':[1.6, 1.51, 1.4, 1.3, 1.41, 1.39, 1.33, 1.46, 1.45, 1.43],'boys;kg':[39.0, 40.8, 43.2, 40.8, 43.1, 38.6, 41.4, 40.6, 36.3],'boys;m':[1.38, 1.5, 1.32, 1.25, 1.37, 1.48, 1.25, 1.49, 1.46],} if __name__ == '__main__':    main(data)```* 上面显示重要的部分：    * 外层for循环每次迭代会创建一个grouper实例，赋值给group变量，group是委派生成器。    * 调用next（group），预激委派生成器grouper，此时进入while True循环，调用子生成器averager后，在yield from表达式处暂停。    * 内层for循环调用group.send(value)，直接把值传给子生成器averager，同时，当前的grouper实例在yield from表达式处暂停。    * 内层循环结束后，group实例依旧在yield from表达式处暂停，因此，grouper函数定义体中为`results[key]`赋值的语句还没有执行。    * 如果外层for循环的末尾没有group.send(None)，那么averager子生成器永远不会终止，委派生成器group永远不会再次激活，    因此永远不会为`results[key]`赋值。    * 外层for循环重新迭代时会创建新的grouper实例，然后绑定到group变量上，前一个grouper实例被垃圾回收程序回收。> 这个试验表明关键一点是：如果子生成器不终止，委派生成器会在yield from表达式处永远暂停。如果是这样，程序不会向前执行，因为yield from把控制权转交给客户代码了。### 16.8 yield from的意义* yield from结构的另外两个特性与异常和终止相关    1. 传入委派生成器的异常，除了GeneratorExit之外都传给了子生成器的throw方法。如果调用throw方法时抛出了，stopIteration    异常，委派生成器恢复运行。StopIteration之外的向上冒泡，传给委派生成器。    2. 如果把GeneratorExit异常传入委派生成器，或者在委派生成器上调用close方法，那么在子生成器上调用close方法，如果    存在的话。            