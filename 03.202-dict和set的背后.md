#### 字典的散列表* 散列表其实是一个稀疏数组，在一般的数据结构教材中，散列表里单元通常叫做表元，在dict的散列表中，每个键值对都占一个表元，每个表元都有两部分，一个是对键的引用，一个是对值得引用。* 散列表算法：为了获取my_dict[search_key]背后的值，python首先调用hash（search_key）计算散列值，把这个值得最低几位作为偏移量，查找表元，如果表元为空，抛出异常，如果不为空，比较found_key == search_key为真，返回found_value* 如果不相等，就是散列冲突，再取几位重复上面过程。```MAX_BITS = len(format(sys.maxsize, 'b'))print('%s-bit Python build' % (MAX_BITS + 1))def hash_diff(o1, o2):    h1 = '{:>0{}b}'.format(hash(o1), MAX_BITS)    h2 = '{:>0{}b}'.format(hash(o2), MAX_BITS)    diff = ''.join('!' if b1 != b2 else ' ' for b1, b2 in zip(h1, h2))    count = '!= {}'.format(diff.count('!'))    width = max(len(repr(o1)), len(repr(o2)), 8)    sep = '-' * (width * 2 + MAX_BITS)    return '{!r:{width}} {}\n{:{width}} {} {}\n{!r:{width}} {}\n{}'.format(    		o1, h1, ' ' * width, diff, count, o2, h2, sep, width=width)if __name__ == '__main__':    print(hash_diff(1, 1.0))    print(hash_diff(1.0, 1.0001))    print(hash_diff(1.0001, 1.0002))    print(hash_diff(1.0002, 1.0003))        输出：64-bit Python build1        000000000000000000000000000000000000000000000000000000000000001                                                                         != 01.0      000000000000000000000000000000000000000000000000000000000000001-------------------------------------------------------------------------------1.0      000000000000000000000000000000000000000000000000000000000000001                        !! !   !! !! !!!   ! !!! ! !!   !!!   !          != 211.0001   000000000000000110100011011011100010111010110001110001000000001-------------------------------------------------------------------------------1.0001   000000000000000110100011011011100010111010110001110001000000001                       ! !!!  ! !! !!  !  !!!  !!!! !  !  !  !!          != 221.0002   000000000000001101000110110111000101110101100011100010000000001-------------------------------------------------------------------------------1.0002   000000000000001101000110110111000101110101100011100010000000001                      !!!! ! !!  !  ! !! !! !   ! !!! !! !!   !          != 231.0003   000000000000010011101010010010101000110000010101010011000000001-------------------------------------------------------------------------------```#### dict的实现及其导致的结果1. 键必须是可散列的* 支持hash()函数，并通过__hash__()方法所得到的散列值是不变的* 支持通过 `__eq__`（）方法检测相等* 如 a==b，则 hash(a) == hash(b)* 所有由用户自定义的对象默认都是可散列的，散列值由id（）获得，而且它们都是不相等的。* 如果你实现了一个类的 `__eq__` 方法，并且希望它可散列，那么一定要实现 `__hash__()`方法，保证如 a==b，则 hash(a) == hash(b)。2. 字典在内存开销巨大* 由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上效率低下。* 如果你需要存放大量巨大的记录，那么放在由元组或者具名元组构成的列表中会是比较好的选择，最好不要根据JSON风格，用字典组成列表存放    * 避免散列表所带来的空间开销    * 无需把记录中的字段的名字在每个元素里都存一遍    #### 往字典里添加新建可能会改变已有键的顺序* 存放元素有时会发生散列冲突，导致新的散列表的次序变化，如何发生依赖于字典背后的实现，所以，不要同时对字典进行迭代和修改。