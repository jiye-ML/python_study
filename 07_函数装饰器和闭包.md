* 函数装饰器用于在原码中标记函数，以某种方式增强函数的行为。* 除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础。* 本章的最终目标是解释清楚函数装饰器的工作原理，包括最简单的注册装饰器和较复杂的参数装饰器，* 在实现这一目标之前，我们需要讨论下面话题：    * python如何计算装饰器句法    * python如何判断变量是不是局部变量    * 闭包存在的原因和工作原理    * nonlocal能解决什么问题* 掌握了这些知识后，进一步讨论装饰器    * 实现行为良好的装饰器    * 标准库中有用的装饰器    * 实现一个参数化装饰器        ### 7.1 装饰器基础知识* 装饰器是可调用的对象，其参数是另一个函数（被装饰的函数），装饰器可能会处理被装饰的函数，然后把它返回，或者将其换成另外一个函数或可调用对象。```@decoratedef target():    print("running target()")等价于下面写法def target():    print("running target()")target = decorate(target)```* 元编程： 在运行时改变程序的行为* 装饰器的一大特性是，能把被装饰的函数替换成其他函数，第二个特性是，装饰器在加载模块时立即执行。### 7,2 python何时执行装饰器* 装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。* 装饰器通常在一个模块中定义，然后应用到其他模块中的函数上。* 实际上，大多数装饰器会在内部定义一个函数，然后将其返回。### 7.3 使用装饰器改进策略模式#### 7.4 变量作用于规则### 7.5 闭包* 闭包指延伸了作用域的函数，其中包含函数定义体中引用，但是不在定义体中定义的非全局变量。```def make_averager():    # 下面是闭包    series = []        def averager(new_value):        # 这是一个自由变量        series.append(new_value)        total = sum(series)        return total/len(series)            return averager```* `avg.__closure__`中的各个元素对应于`avg.__code__.co_freevars`中的一个名称，这些元素是cell对象，有个cell_contents属性。```>>> avg.__code__.co_freevars('series',)>>> avg.__closure__(<cell at 0x107a44f78: list object at 0x107a91a48>,)>>> avg.__closure__[0].cell_contents[10, 11, 12]```* 闭包是一个一种函数，它会保留定义函数是存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用了，但是人能使用那些绑定。* 注意：只有嵌套在其他函数中的函数才可能需要处理不在全部作用域中的外部变量。### 7.6 nonlcal申明* 相当于回溯变量的作用域```def fun():    a = 0    def fun2():        nonlcal a        a = 7    这个时候a = 7在fun函数中```### 7.7 实现一个简单的装饰器```def colck(func):    def clocked(*args)：        return result    return clocked```* functools.wraps装饰器把相关的属性从func赋值到clocked，此外，还能正确处理关键字参数。```def colck(func):    @functools.warps(func)    def clocked(*args, **kwargs)：        return result    return clocked```### 7.8 标准库中的装饰器* python内置了三个用于装饰方法的函数，property, clasmethod, staticmethod,* 还有常见的一个装饰器 functools.wraps#### 使用 functools.lru_cache做备忘* functools.lru_cache实现了备忘录功能，这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数是重复计算。```@functools.lru_cache()@clockdef fibnacci(n):    if n < 2:        return n    return fibonacci(n - 2) + fibonacci(n - 1)```* 注意，必须像常规函数那样调用lru_cache，这么做的原因是，lru_cache可以接受配置参数。* lru_cache可以使用两个可选的参数，    * functools.lru_cache(maxsize=128, typed=False)* type参数设为True，把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数区分开来，* lru_cache使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，参数必须可散列化。#### 单分配反函数* python不支持重载方法和函数* functools.singledispatch装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。```from functools import singledispatchfrom collections import abcimport numbersimport html@singledispatch def htmlize(obj):    content = html.escape(repr(obj))    return '<pre>{}</pre>'.format(content)@htmlize.register(str) def _(text):     content = html.escape(text).replace('\n', '<br>\n')    return '<p>{0}</p>'.format(content)@htmlize.register(numbers.Integral) def _(n):    return '<pre>{0} (0x{0:x})</pre>'.format(n)@htmlize.register(tuple) @htmlize.register(abc.MutableSequence)def _(seq):    inner = '</li>\n<li>'.join(htmlize(item) for item in seq)    return '<ul>\n<li>' + inner + '</li>\n</ul>'```* 处理重载问题* 只要可能，注册的专门函数应该处理抽象基类（numbers.Integral,abc.MutableSequence），不要处理具体实现。* singledispatch机制的一个显著特征是，你可以在系统任何地方和任何模块中注册专门的函数，如果后来在新的模块中定义了新的类型，可以轻松的添加一个新的专门的函数来处理那个类型。* 装饰器是函数，因此可以组合起来使用。```@d1@d2de fun()```### 7.10 参数化装饰器* 解析源码中的装饰器时，python把被装饰的函数作为一个参数传给装饰器函数。* 接受其他参数的方法：创建一个装饰器工厂函数，把参数传给它，返回一个装饰器，然后在把它应用到要装饰的函数上。#### 一个参数化的注册装饰器```registry = set() def register(active=True):     def decorate(func):         print('running register(active=%s)->decorate(%s)' % (active, func))        if active:             registry.add(func)        else:          registry.discard(func)         return func     return decorate     @register(active=False) def f1():    print('running f1()')    @register() def f2():    print('running f2()')    def f3():print('running f3()')```> 几点说明：1. decorate是装饰器，必须返回一个函数2. register是装饰器工厂函数，因此返回decorate3. @register工厂函数必须作为函数调用，并且传入所需要的参数。4. 即使不传入参数，register也必须作为函数调用，既要返回真正的装饰器decorate。* 装饰器最好通过实现`__call__`方法的类实现，不应该使用函数实现。### 7.2 本章小结* 参数化装饰器基本上都涉及至少两层嵌套函数，如果想使用@functools.wraps生成装饰器，为高级技术支持，可能需要更深的嵌套。* functools两个出色的函数装饰器    * @lru_cache()    * @singleddispatch* 理解装饰器，需要区分导入时和运行时，还要知道变量作用域，闭包和增加的nonlocal申明。* 装饰器模式的一般描述：动态给一个对象添加一些额外的职责，就扩展功能而言，装饰器模式比子类化更灵活。* 