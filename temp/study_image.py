import cv2import numpy as npfrom matplotlib import pyplot as pltclass CV2ImageOP(object):    ''' 1、 图像读取和写入 '''    # 第二个参数是要告诉函数应该如何读取这幅图片。    # • cv2.IMREAD_COLOR：读入一副彩色图像。图像的透明度会被忽略， 这是默认参数。    #  • cv2.IMREAD_GRAYSCALE：以灰度模式读入图像    @staticmethod    def imread(image_path):        return cv2.imread(image_path)        pass    @staticmethod    def imshow(img):        cv2.imshow('image', img)        pass    ''' 2、 绘制图像和打印文字 '''    @staticmethod    def base_shape():        img = np.zeros((512, 512, 3), np.uint8)        cv2.line(img, (0, 0), (511, 511), (255, 0, 0), 5)        cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3)        # 半径 圆心        cv2.circle(img, (120, 63), 63, (0, 0, 255), -1)        # 一个参数是中心点的位置坐标。 下一个参数是长轴和短轴的长度。        # 椭圆沿逆时针方向旋转的角度。椭圆弧演顺时针方向起始的角度和结束角度，如果是 0很 360，就是整个椭圆        cv2.ellipse(img, (256, 256), (100, 50), 0, 0, 180, 255, -1)        # 多边形        pts = np.array([[10, 5], [20, 30], [70, 20], [50, 10]], np.int32)        # # 这里 reshape 的第一个参数为-1, 表明这一维的长度是根据后面的维度的计算出来的。        pts = pts.reshape((-1, 1, 2))        cv2.polylines(img, pts, True, (0, 0, 255))        CV2ImageOP.imshow(img)        # 键盘绑定函数。需要指出的是它的时间尺度是毫 秒级。函数等待特定的几毫秒，        # 看是否有键盘输入。特定的几毫秒之内，如果 按下任意键，这个函数会返回按键的 ASCII 码值，        cv2.waitKey(0)        cv2.destroyAllWindows()        pass    @staticmethod    def put_text(message='OPENCV'):        img = np.zeros((512, 512, 3), np.uint8)        font = cv2.FONT_HERSHEY_SIMPLEX        cv2.putText(img, message, (10, 500), font, 4, (255, 255, 255), 2)        CV2ImageOP.imshow(img)        pass    '''  3、 像素操作，通道 '''    @staticmethod    def piexl(img):        # 读像素内容        px = img[100, 100]        print(px)        blue = img[100, 100, 0]        print(blue)        # 修改像素值        img[100, 100] = [255, 255, 255]        print(img[100, 100])        # 图像属性（行、列、通道、图像数据类型、像素数目）        print(img.shape)        # 图像的像素数目        print(img.size)        # 图像的数据类型        print(img.dtype)        # 图像的 ROI        ball = img[280:340, 330:390]        img[273:333, 100:160] = ball        # 拆分及合并图像通道        b, g, r = cv2.split(img)        img = cv2.merge(b, g, r)        pass    # 边界扩展    @staticmethod    def border(img):        BLUE = [255, 0, 0]        # – cv2.BORDER_REPLICATE 重复最后一个元素。 例如: aaaaaa| abcdefgh|hhhhhhh 41        replicate = cv2.copyMakeBorder(img, 10, 10, 10, 10, cv2.BORDER_REPLICATE)        #  – cv2.BORDER_REFLECT 边界元素的镜像。 比如: fedcba|abcde-fgh|hgfedcb        reflect = cv2.copyMakeBorder(img, 10, 10, 10, 10, cv2.BORDER_REFLECT)        # – cv2.BORDER_REFLECT_101 or cv2.BORDER_DEFAULT 跟上面一样，但稍作改动。例如: gfedcb|abcdefgh|gfedcba        reflect101 = cv2.copyMakeBorder(img, 10, 10, 10, 10, cv2.BORDER_REFLECT_101)        # – cv2.BORDER_WRAP 不知道怎么说了,就像这样: cdefgh| abcdefgh|abcdefg • value 边界颜色        wrap = cv2.copyMakeBorder(img, 10, 10, 10, 10, cv2.BORDER_WRAP)        # cv2.BORDER_CONSTANT 添加有颜色的常数值边界，还需要 下一个参数（value） 。        constant = cv2.copyMakeBorder(img, 10, 10, 10, 10, cv2.BORDER_CONSTANT, value=BLUE)        plt.subplot(231), plt.imshow(img, 'gray'), plt.title('ORIGINAL')        plt.subplot(232), plt.imshow(replicate, 'gray'), plt.title('REPLICATE')        plt.subplot(233), plt.imshow(reflect, 'gray'), plt.title('REFLECT')        plt.subplot(234), plt.imshow(reflect101, 'gray'), plt.title('REFLECT_101')        plt.subplot(235), plt.imshow(wrap, 'gray'), plt.title('WRAP')        plt.subplot(236), plt.imshow(constant, 'gray'), plt.title('CONSTANT')        plt.show()        pass    @staticmethod    def arithmetic(img):        # 图像混合        img2 = CV2ImageOP.imread('data/opencv_logo.png')        # dst = img1 + img2 + r        dst = cv2.addWeighted(img, 0.7, img2, 0.3, 0)        cv2.imshow('dst', dst)        cv2.waitKey(0)        cv2.destroyAllWindows()        pass    passif __name__ == '__main__':    img = CV2ImageOP.imread('data/test.jpg')    CV2ImageOP.arithmetic(img)