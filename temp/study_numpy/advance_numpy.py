'''深入剖析numpy'''import numpy as np'''ndarray对象的内部机理numpy的ndarray提供了一种将同质数据块解释为多维数组对象的方式，数据类型决定了解释方式；ndarray如此强大的部分原因是所有数组对象都是数据块的一个跨度视图；简单地说，ndarray不只是一块内存和一个dtype，它还有跨度信息，这使得数组能以各种步幅在内存中移动：【ndarray的内部结构.png】    * 一个指向数组的指针    * 数据类型或dtype    * 一个表示数组形状的元组    * 一个跨度元组，其中整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。''''''numpy数据类型体系【numpy的dtype体系.png】''''''数组重塑'''# 将一维数组转换为多维数组arr = np.arange(8)arr.reshape((4, -1))# 将多维数组转换为一维数组，扁平化arr = np.arange(15).reshape((5, 3))# 不产生数据的副本np.ravel(arr)# 产生数据的副本arr.flatten()# 存放按行优先还是按列优先np.ravel(arr, 'F') # fortran顺序，行优先np.ravel(arr, 'C') # c顺序，列优先'''数组的合并和拆分[数组连接函数.png]'''# concatenate可以按指定轴将一个数组组成的序列连接到一起arr = np.array([[1, 2, 3], [4, 5, 6]])arr2 = np.array([[7, 8, 9], [10, 11, 12]])np.concatenate([arr, arr2], axis=0)# 对于常见的连接操作，numpy操作提供一些比较方便的方法（如vstack和hstack），因为，上面的运算还可以表达为np.vstack((arr, arr2))np.hstack((arr, arr2))# split用于将一个数组沿着指定轴拆分为多个数组arr = np.random.randn(5, 2)print(arr)first, second, third = np.split(arr, [1, 3])print(first)print(second)print(third)'''元素的重复操作：tile和repeat'''arr = np.arange(3)# 每个元素重复相同的次数arr.repeat(3)# 每个元素重复不同的次数arr.repeat([2, 3, 4])# tile的功能是沿指定轴向堆叠数组的副本np.tile(arr, 2)'''广播不同形状的数组之间的算术运算的执行方式.广播的原则如果两个数组的后缘维度（从末尾开始算起的维度）的轴长度相符或其中一方的长度为1，则认为它们是广播兼容的。广播会缺失和（或）长度为1的维度上进行'''# 将标量值和数组合并时会发生最简单的广播arr = np.arange(5)# 标量4倍广播到其他所有元素上arr * 4'''ufunc高级应用[ufunc的方法.png]'''# reduce接受数组参数，并通过一系列的二元运算对其进行聚合，arr = np.arange(10)print(np.add.reduce(arr))print(arr.sum())# 下面使用np.logical_and检查数组各行中的值是否有序的arr = np.random.randn(5, 5)arr[::2].sort(1) # 对部分行进行排序np.logical_and.reduce(arr[:, :-1] < arr[:, 1:], axis=1) # 与all方法等价# accumulate 跟reduce的关系就像cumsum跟sum的关系那样，产生一个跟原数组大小相同的中间“累计”值数组arr = np.arange(15).reshape((3, 5))np.add.accumulate(arr, axis = 1)# outer 用于计算连个数组的叉积arr = np.arange(3).repeat([1, 2, 2])np.multiply.outer(arr, np.arange(5))'''自定义ufunc有两个工具，numpy.frompyfunc接受一个python函数以及两个分别表示输入输出参数数量的整数，三个参数： 函数，输入的数量，输出的数量frompyfunc创建的函数总是返回python对象数组numpy.vetorize这两个函数都非常慢，因为每个元素都会执行一次python函数调用，这自然会比numpy自带的基于c的ufunc慢'''# 实现元素级加法的简单函数def add_elements(x, y):    return x + y# 两个参数表示输入的数量和输出的数量add_them = np.frompyfunc(add_elements, 2, 1)add_them(np.arange(8), np.arange(8))# numpy.vetorizeadd_them = np.vectorize(add_elements, otypes=[np.float64])add_them(np.arange(8), np.arange(8))'''结构化和记录式数组结构化数组是一种特殊的ndarray，其中的每个元素可以被看做c语言中的结构体定义结构dtype方式很多，最典型的办法是元组列表，各元组的格式（field_name, field_data_type）， 这样数组中的每个元素就是个元组'''dtype = [("x", np.float64), ('y', np.int32)]sarr = np.array([(1.5, 6), (np.pi, -2)], dtype=dtype)sarr[0] # 第一个元素sarr['x'] # 所有x的字段'''嵌套dtype和多维字段'''# 定义结构化dtype时，可有设置一个形状dtype = [('x', np.int64, 3), ('y', np.int32)]'''为什么要用结构化数组将单个内存块解释为带有任意复杂嵌套列的表格型结构，由于数组中的每个元素在内存中都被表示为固定的字节数，所以结构化数组能够提供非常快速高效的磁盘读写''''''更多排序的话题跟python内置的列表一样，ndarray的sort实例方法也是也是就地排序相反，numpy.sort会为原数组创建一个已排序的副本，它接受参数''''''简介排序：argsort和lexsort'''values = np.array([5, 0, 1, 3, 2])indexer = values.argsort()values[indexer]# numpy.searchsorted：在有序的数组总查找元素# 在一个有序数组上执行二分查找的数组方法，只要将值插入到返回的那个位置就能维持数组有序arr = np.array([0, 1, 7, 12, 15])arr.searchsorted(9)'''numpy的matrix类不建议使用''''''性能建议* 将python循环和条件逻辑转换为数组运算和布尔数组运算* 尽量使用广播* 避免复制数据，尽量使用数组视图* 利用ufunc及其各种方法'''