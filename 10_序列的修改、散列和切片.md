### 10.1 Vector类：用户定义的序列类型### 10.2 Vector类第一版* reprlib.repr的方式，这个函数用于生成大型结构或递归结构的安全表示形式，它会限制输出字符串的长度，用 `...`表示截断的部分。* repr（）函数的目的是调试，因此绝对不能抛出异常，如果 `__repr__`方法的实现出现问题，那么必须处理，尽量输出有用的内容，让用户能够识别目标对象。### 10.3 协议和鸭子类型* 在面向对象编程中，协议是非正式的接口，只在文档中定义，在代码中不定义。* 协议是非正式的，没有强制力，因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分，例如，为了支持迭代，只需要实现 `__getitem__`方法，没有必要提供 `__len__`。### 10.4 可切片的序列```class Vector():    def __len__(self):        return len(self._data)    def __getitem__(self, index):        return self._data[index]```* 切片原理：dir(slice)得到的结果是一个indices属性，* s.indeces(len) -> （start, stop, stride）:给定长度len的序列，计算s表示的扩展切片的起始地址（start），和结尾（stop）索引，以及长度超出目标序列的切片，这个方法会整顿元组，把start,stop,stride变为非负数，而且都落在指定长度序列的边界内。### 10.5 动态存取属性* 属性查找失败后，解释器会调用 `__getattr__`方法，简单来说，对 `my_obj.x`表达式，python会检查 my_obj实例有没有x属性，如果没有，到类（`my_obj.__class__`）中查找，如果还没有，就顺着继承树继续查找，如果依旧没有找到，调用 my_obj的定义的 `__getattr__`方法，传入self和属性名称的字符串形式。```shrotcut_names = 'xyzt'def __getattr__(self, name):    cls = type(self)            if len(name) == 1:        pos = pos.shortcut_names.find(name)        if 0 <= pos < len(self._componts[pos]):            return self._components[pos]    msg = '{.__name__!r} object has no attribute {!r}'    raise AttributeError(msg.format(cls, name))```* 为了保持行为的一致性：```def __setattr__(self, name, value):    cls = type(self)    if len(name) == 1:        if name in cls.shortcut_name:            error = 'readonly attribute {attr_name~!r}'        elif name.islower():            error = 'can't set attribute a to z in {cls_name!r}'        else:            error = ''        if error:            msg = error.format(cls_name=cls.__name__, attr_name=name)            raise AttributeError(msg)    super().__setattr__(name, value)```* super()函数用于动态访问超类的方法，对python这样支持多重继承的动态语言来说，必须能这么做，程序员经常使用这个函数把子类方法的某些任务托给超类中适当的方法。### 10.6 vector类：散列和快速等值测试![](readme/reduce.jpg)* operator模块以函数的形式提供了python全部的中缀运算符，从而减少了使用lambda表达式。#### 10.7 vector类：格式化* [vector类](10_序列的修改、散列和切片/Vector.py)### 杂谈* 向熟悉正式接口的人解释协议时，我会简单说它是非正式的接口。* python文档中，如果看到文件类对象这样的表述，通常说的就是协议，这是一种简短的说法，意思是:行为基本与文件一致，实现了部分文件接口，满足上下文相关需求的东西。* 如果你想计算列表中各个元素的和，写出的代码应该看起来像是在计算元素之和，而不是迭代元素，维护一个变量。再执行一系列求和操作，如果不能站在一定高度表明意图，让语言自己去关注底层操作，那么要高层语言干嘛？  