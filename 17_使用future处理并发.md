### 17.1 示例：网络下载的三种风格* [每次串行保存一张从网上下载的图片](17_使用future处理并发/flags.py)#### 使用concurrent.furtures模块下载* 主要特色是ThreadPoolExecutor和ProcessPoolExecutor类，这两个类实现的接口能分别在不同的线程或进程中执行可调用对象。* 这两个类的内部维护者一个工作线程和进程池，以及要执行的任务队列。* [多线程完成网上下载图片任务](17_使用future处理并发/flags_threadpool.py)#### future在哪里* [代码拆解，剖析future出现的地方](17_使用future处理并发/flags_threadpool_ac.py)* 我们目前测试的并发脚本都不能并行下载，使用concurrent.future库实现的那两个示例受GIL(global interpreter lock，全局解释器锁)限制。### 17.2 阻塞型IO和GIL* cpython解释器本身就不是线程安全的，因此有全局解释器锁，，一次只允许使用一个线程执行python字节码。因此，一个python进程通常不能同时使用多个cpu核心。* 标准库中农所有执行的阻塞型io操作的函数，在等待操作系统返回结果时都会释放GIL。这意味着python语言这个层次可以使用多线程。而io密集型python程序都从中收益：一个python线程等待网络响应时，阻塞型io函数会释放GIL，再运行一个线程。```with futures.ThreadPoolExcutor(workers) as excutor```### 17.3 使用concurrent.futures模块启动进程* 解决cpu密集任务```with futures.ProcessPoolExecutor() as excutor```### 17.4 实验Executor.map方法* [使用代码测试不同情况](17_使用future处理并发/demo_executor_map.py)* executor.submit和futures.as_complete这个组合比executor.map更灵活，因为submit方法能处理不同的可调用对象和参数，而executor.map只能处理参数不同的同一个可调用对象。此外，传给futures.as_completed函数的future集合可以来自多个Executor实例，例如一些由ThreadPoolExecutor实例创建。### 17.5 显示下载进度并处理错误* 代码呈现为 flag2系列* 测试并发客户端时要小心：在公开HTTP服务器上测试HTTP并发客户端时要小心，因为每秒可能会发起很多请求，这相当于拒绝服务（DOS）攻击。做并发实验的饿时候，应该在本地搭建HTTP服务器功测试， [具体参见](17_使用future处理并发/README.rst)。### 自己的理解* 线程： 用于io密集型* 进程：用于cpu密集型