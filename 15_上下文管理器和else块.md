* 我们要讨论的特性    * with语句和上下文管理器    * for,while,try语句的else语句* with语句会设置一个临时的上下文，交给上下文管理器对象控制，并且负责清理上下文。这么做能避免错误并减少样本代码，因此API更安全，而且更易于使用。### 15.1 先做这个，再做那个：if语句之外的else块### 15.2 上下文管理器和with块* with语句的目的是简化try/finally模式，这种模式用于保证一段代码* with语句的目的是简化try/finally模式，这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常，return语句或sys.exit调用而终止，也会执行指定的操作，finally子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。* 上下文管理器协议包含 `__enter__`和 `__exit__`两个方法，with语句开始运行时，会在上下文管理器对象上调用 `__enter__`方法，with语句结束后会调用 `__exit__`方法。以此扮演finally子句的角色。```>>> from mirror import LookingGlass>>> with LookingGlass() as what: ➊...     print('Alice, Kitty and Snowdrop') ➋...     print(what)...pordwonS dna yttiK ,ecilA ➌YKCOWREBBAJ>>> what ➍'JABBERWOCKY'22>>> print('Back to normal.') ➎Back to normal.``````class LookingGlass:    def __enter__(self): ➊        import sys        self.original_write = sys.stdout.write ➋        sys.stdout.write = self.reverse_write ➌        return 'JABBERWOCKY' ➍    def reverse_write(self, text): ➎        self.original_write(text[::-1])    def __exit__(self, exc_type, exc_value, traceback): ➏        import sys ➐        sys.stdout.write = self.original_write ➑        if exc_type is ZeroDivisionError: ➒            print('Please DO NOT divide by zero!')            return True ➓```* 解释器调用 `__enter__`方法时，除了隐式self外，不会传入任何参数，传给 `__exit__`方法的参数三个：    * exec_type: 异常类    * exec_value: 异常实例，有时会有参数传给异常构造方法，例如错误消息，这些参数可以使用exec_value.args获取    * traceback： traceback对象### 15.3 contextlib模块中的使用工具* closing：如果对象提供了close方法，但没有实现 `__enter__/__exit__`协议，那么可以使用这个函数构建上下文管理器* suppress：构建临时忽略指定异常的上下文管理器* @contentmanger: 这个装饰器把简单的生成器函数编程上下文管理器，这样就不用创建类去实现管理器协议了。* contextDecorator: 这个是基类，用于定义基于类的上下文管理器，这种上下文管理器也能用于装饰器函数，在受管理器的上下文中运行整个函数。* ExitStack：这个上下文管理器能进入多个上下文管理器，with块结束时，ExitStack按照后进先出的顺序调用栈中各个上下文管理器的 `__exit_`方法，如果事先不知道with块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件。### 15.4 使用@contextmanager* @contextmanager装饰器能减少创建上下文管理器的样本代码量，因为不用编写一个完整的类，只需要实现yield语句的生成器，* 在使用@contextmanager装饰的生成器中，yield语句的作用是函数的定义体分成两部分：yield语句前面的所有代码在with开始时执行，yield语句后面的代码在with块结束时执行。```@contextlib.contextmanager ➊def looking_glass():    import sys    original_write = sys.stdout.write ➋        def reverse_write(text): ➌           original_write(text[::-1])  # 闭包中闭包中，可以访问            sys.stdout.write = reverse_write ➍    yield 'JABBERWOCKY' ➎    sys.stdout.write = original_write ➏```* contextib.contextmanager装饰器会把函数包装成实现了 `__enter__/__exit__`方法的类    * 这个类的 `__enter__`方法的作用：        1. 调用生成器函数，保存生成器对象        2. 调用next（gen）,执行到yield关键字所在的位置        3. 返回next(gen)产出的结果，以便把产出的值绑定到with/as语句中的目标变量上    * with块终止时， `__exit__`方法会做一下几件事情        1. 检查有没有异常传给exec_type,如果有，调用gen.trow(exception)，在生成器函数定义体中包含yield关键字那一行抛出异常。        2. 否则，调用next(gen)，继续执行生成器函数中yield后面的代码。```@contextlib.contextmanagerdef looking_glass():    import sys    original_write = sys.stdout.write        def reverse_write(text):        original_write(text[::-1])            sys.stdout.write = reverse_write    msg = '' ➊    try:        yield 'JABBERWOCKY'    except ZeroDivisionError: ➋        msg = 'Please DO NOT divide by zero!'    finally:        sys.stdout.write = original_write ➌        if msg:            print(msg)```* 使用@contextmangager装饰器时，要把yield语句放在try/finally语句中，这是无法避免的，因为我们永远不知道上下文管理器的用户会对with块做什么。