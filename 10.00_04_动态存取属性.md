### 10.5 动态存取属性* 属性查找失败后，解释器会调用 `__getattr__`方法，简单来说，对 `my_obj.x`表达式，python会检查 my_obj实例有没有x属性，如果没有，到类（`my_obj.__class__`）中查找，如果还没有，就顺着继承树继续查找，如果依旧没有找到，调用 my_obj的定义的 `__getattr__`方法，传入self和属性名称的字符串形式。```shrotcut_names = 'xyzt'def __getattr__(self, name):    cls = type(self)            if len(name) == 1:        pos = pos.shortcut_names.find(name)        if 0 <= pos < len(self._componts[pos]):            return self._components[pos]    msg = '{.__name__!r} object has no attribute {!r}'    raise AttributeError(msg.format(cls, name))```* 为了保持行为的一致性：```def __setattr__(self, name, value):    cls = type(self)    if len(name) == 1:        if name in cls.shortcut_name:            error = 'readonly attribute {attr_name~!r}'        elif name.islower():            error = 'can't set attribute a to z in {cls_name!r}'        else:            error = ''        if error:            msg = error.format(cls_name=cls.__name__, attr_name=name)            raise AttributeError(msg)    super().__setattr__(name, value)```* super()函数用于动态访问超类的方法，对python这样支持多重继承的动态语言来说，必须能这么做，程序员经常使用这个函数把子类方法的某些任务托给超类中适当的方法。