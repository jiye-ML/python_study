### 15.4 使用@contextmanager* @contextmanager装饰器能减少创建上下文管理器的样本代码量，因为不用编写一个完整的类，只需要实现yield语句的生成器，* 在使用@contextmanager装饰的生成器中，yield语句的作用是函数的定义体分成两部分：yield语句前面的所有代码在with开始时执行，yield语句后面的代码在with块结束时执行。```@contextlib.contextmanager ➊def looking_glass():    import sys    original_write = sys.stdout.write ➋        def reverse_write(text): ➌           original_write(text[::-1])  # 闭包中，可以访问            sys.stdout.write = reverse_write ➍    yield 'JABBERWOCKY' ➎    sys.stdout.write = original_write ➏```* contextib.contextmanager装饰器会把函数包装成实现了 `__enter__/__exit__`方法的类    * 这个类的 `__enter__`方法的作用：        1. 调用生成器函数，保存生成器对象        2. 调用next（gen）,执行到yield关键字所在的位置        3. 返回next(gen)产出的结果，以便把产出的值绑定到with/as语句中的目标变量上    * with块终止时， `__exit__`方法会做一下几件事情        1. 检查有没有异常传给exec_type,如果有，调用gen.trow(exception)，在生成器函数定义体中包含yield关键字那一行抛出异常。        2. 否则，调用next(gen)，继续执行生成器函数中yield后面的代码。```@contextlib.contextmanagerdef looking_glass():    import sys    original_write = sys.stdout.write        def reverse_write(text):        original_write(text[::-1])            sys.stdout.write = reverse_write    msg = '' ➊    try:        yield 'JABBERWOCKY'    except ZeroDivisionError: ➋        msg = 'Please DO NOT divide by zero!'    finally:        sys.stdout.write = original_write ➌        if msg:            print(msg)```* 使用@contextmangager装饰器时，要把yield语句放在try/finally语句中，这是无法避免的，因为我们永远不知道上下文管理器的用户会对with块做什么。