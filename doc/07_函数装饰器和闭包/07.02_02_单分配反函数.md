#### 单分配反函数* python不支持重载方法和函数* functools.singledispatch装饰器可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。```from functools import singledispatchfrom collections import abcimport numbersimport html@singledispatch def htmlize(obj):    content = html.escape(repr(obj))    return '<pre>{}</pre>'.format(content)@htmlize.register(str) def _(text):     content = html.escape(text).replace('\n', '<br>\n')    return '<p>{0}</p>'.format(content)@htmlize.register(numbers.Integral) def _(n):    return '<pre>{0} (0x{0:x})</pre>'.format(n)@htmlize.register(tuple) @htmlize.register(abc.MutableSequence)def _(seq):    inner = '</li>\n<li>'.join(htmlize(item) for item in seq)    return '<ul>\n<li>' + inner + '</li>\n</ul>'```* 处理重载问题* 只要可能，注册的专门函数应该处理抽象基类（numbers.Integral,abc.MutableSequence），不要处理具体实现。* singledispatch机制的一个显著特征是，你可以在系统任何地方和任何模块中注册专门的函数，如果后来在新的模块中定义了新的类型，可以轻松的添加一个新的专门的函数来处理那个类型。* 装饰器是函数，因此可以组合起来使用。```@d1@d2de fun()```