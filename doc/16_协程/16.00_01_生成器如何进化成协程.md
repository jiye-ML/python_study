### 16.1 生成器如何进化成协程* 可以使用send()方法发送数据，发送的数据会成为生成器函数中yield表达式的值，因此，生成器可以视作协程使用。协程是指一个过程，这个过程与调用方写作，产出由调用方提供的值```>>> def simple_coroutine(): # ➊    ... print('-> coroutine started')    ... x = yield # ➋  yield在表达式中使用，如果协程只需要从客户端那里接收数据，    ... print('-> coroutine received:', x)...>>> my_coro = simple_coroutine()>>> my_coro # ➌与创建生成器方法一样， 调用函数得到生成器对象<generator object simple_coroutine at 0x100c2be10>>>> next(my_coro) # ➍首先调用next函数，因为生成器函数还没有启动，没在yield语句处暂停，所以一开始无法发送数据。-> coroutine started>>> my_coro.send(42) # ➎-> coroutine received: 42Traceback (most recent call last): # ➏...StopIteration```* 协程可以身处四个状态中的一个，当前状态可以使用inspect.getgeneratorstate()函数确定。    * GEN_CREATED: 等待开始执行    * GEN_RUNNING 解释器正在执行    * GEN_SUSPENDED：在yield表达式处暂停    * GEN_CLOSE：执行结束* 因为send方法的参数会成为暂停yield表达式的值，所以，仅当协程处于暂停状态时才能调用send方法。不过协程还没有激活，情况就不同了，因此，始终要调用next(my_coro)激活协程，也可以调用my_coro.send(None)，效果一样。* 关键的一点是，协程在yield关键字所在的位置暂停执行。前面说过，在赋值语句中，=右边的diamante在赋值之前执行。因此b = yield a这行代码来说。等到客户端代码再激活协程时才会设定b的值，这种行为要花点时间才能习惯，不过一定要理解，这样才能弄懂异步编程中yield的作用。    