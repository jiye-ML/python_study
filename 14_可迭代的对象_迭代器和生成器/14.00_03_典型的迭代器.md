### 14.3 典型的迭代器```RE_WORD = re.compile('\w+')class Sentence:    def __init__(self, text):        self.text = text        self.words = RE_WORD.findall(text)        pass    def __repr__(self):        return 'Sentence{}'.format(reprlib.repr(self.text))    def __iter__(self):        return SentenceIterator()class SentenceIterator:    def __init__(self, words):        self.words = words        self.index = 0    def __next__(self):        try:            word = self.words[self.index]        except IndexError:            raise StopIteration()        self.index += 1        return word    def __iter__(self):        return self```* 把Sentence编程迭代器：坏主意* 构建可迭代对象和迭代器时常会出现错误，原因是混淆了二者，要知道，可迭代的对象有个 `__iter__`方法，每次都实例化一个新的迭代器，而迭代器要实现 `__next__`方法，返回单个元素，此外还要实现 `__iter__`方法，返回迭代器本身。因此，迭代器可以迭代，但是可迭代对象不是迭代器。* 迭代器模式可用来    * 访问一个聚合对象的内容而无需暴露它的内部表示    * 支持对聚合对象的多种遍历    * 为遍历不同的聚合结构提供一个统一的接口（支持多态迭代）* 可迭代的对象一定不能是自身的迭代器，也就是说，可迭代器的对象必须实现 `__iter))`方法，但不能实现 `__next__`方法，另一方面，迭代器应该一直可以迭代，迭代器的 `__iter__`方法应该返回自身。