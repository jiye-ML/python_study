'''实现 __getitem__ 和 __len__'''import collectionsfrom random import choice# namedtuple用于构建只有少数属性但没有方法的对象Card = collections.namedtuple("Card", ['rank', 'suit'])class FrenchDeck:    '''    这样实现的优点：        * 作为你的类用户，不必记住标准操作的各式名称，怎么得到元素总数；        * 可以更加方便利用python标准库，    '''    ranks = [str(n) for n in range(2, 11)] + list("JQKA")    suits = 'spades diamonds clubs hearts'.split()    def __init__(self):        self._cards = [Card(rank, suit) for rank in self.ranks for suit in self.suits]        pass    # 调用len（对象）使用，定义，算是方法重载    def __len__(self):        return len(self._cards)        pass    # []运算符重载    def __getitem__(self, item):        '''        可以实现切片了，因为重新定义了 []        可迭代了，迭代通常是隐式的，譬如说一个集合类型没有实现__contains__方法，in运算符就会按照顺序做一次迭代搜索，        '''        return self._cards[item]        pass    passif __name__ == '__main__':    deck = FrenchDeck()    # 测试长度    len(deck)    # 访问元素    deck[0]    # 随机挑选    print(choice(deck))    # in方法    print(Card("Q", "hearts") in deck)    # 排序，【2，A】【黑桃最大，红桃，方块，梅花最小】    suits_values = dict(spades = 3, hearts = 2, diamonds = 1, clubs = 0)    # 排序    def spades_high(card):        rank_value = FrenchDeck.ranks.index(card.rank)        return rank_value * len(suits_values) + suits_values[card.suit]        pass    for card in sorted(deck, key=spades_high):        print(card)