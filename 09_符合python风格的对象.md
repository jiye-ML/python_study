* 得益于python数据模型，自定义类型的行为可以像内置类型那样自然，实现如此自然的行为，靠的不是继承，而是鸭子类型：我们需要按照预定行为实现对象所需的方法即可。* 这一样说明如何实现在很多python类型中常见的特殊方法。    * 支持用于生成对象其他表示形式的内置函数（repr(),bytes）    * 使用一个类方法，实现备选构造方法    * 扩展内置的format()函数和str.format()方法使用的格式微语言    * 实现只读属性    * 把对象变为可散列的，以便在集合中及作为dict的键使用    * 利用 `__slots__`节省内存。* 两个概念    * 如何以及何时使用@classmethod和@staticmethod装饰器    * python的私有属性和受保护属性的用法，约定，和局限### 9.1 对象表示形式* 获取对象的字符串表示形式1. repr()：以便于开发者理解的方式返回对象的字符串表示形式。2. str()：以便于用户理解的方式返回对象的字符串表示形式。* 实现 `__repr__`和`__str__`特殊方法，为repr()和str()提供支持。### 9.2 再谈向量类```class Vector2d:    typecode = 'd'         def __init__(self, x, y):        self.x = float(x)         self.y = float(y)    def __iter__(self):        return (i for i in (self.x, self.y))     def __repr__(self):        class_name = type(self).__name__        return '{}({!r}, {!r})'.format(class_name, *self)     def __str__(self):        return str(tuple(self))     def __bytes__(self):       return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))     def __eq__(self, other):        return tuple(self) == tuple(other)     def __abs__(self):        return math.hypot(self.x, self.y)     def __bool__(self):        return bool(abs(self))```### 9.3 备选构造方法```@classmethod def frombytes(cls, octets):     typecode = chr(octets[0])     memv = memoryview(octets[1:]).cast(typecode)     return cls(*memv) ```* 类装饰器，是一个类方法，返回类的一个实例，参数中第一个参数必须是类### 9.4 classmethod和staticmethod* classmethod：定义类操作，而不是操作实例的方法，classmethod改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例。classmethod最常见的用途是定义备选构造函数。* staticmethod装饰器也会改变方法的调用方式，但第一个参数不是特殊值，其实，静态方法就是普通函数，只是碰巧在类的定义体中，而不是模块层定义。### 9.5 格式化显示* 内置的format()函数和str.format()方法把各个类型的格式化方式委托给对应的 `.__format__(format_spec)`方法，    * format(my_obj, format_spec)的第二个参数    * str.format()方法的格式字符串，{}里代换字段中冒号后面的部分。    ```    >>> brl = 1/2.43 # BRL到USD的货币兑换比价    >>> brl    0.4115226337448559    >>> format(brl, '0.4f')     '0.4115'    >>> '1 BRL = {rate:0.2f} USD'.format(rate=brl)     '1 BRL = 0.41 USD'    ```### 9.6 可散列的Vector2d* 必须使用 `__hash__`方法* 是向量不可变``` class Vector2d:    typecode = 'd'        def __init__(self, x, y):        self.__x = float(x)         self.__y = float(y)    @property     def x(self):         return self.__x     @property     def y(self):         return self.__y    def __iter__(self):        return (i for i in (self.x, self.y))```* 使用两个前导下滑线，把属性标记为私有* @property装饰器把读值方法标记为特性。* 注意:我们让这些向量不可变是有原因的，因为这样才能实现 `__hash__`方法，这个方法应该返回一个整数，理想情况下，还要考虑对象属性的散列值。* [完整类](9_符合python分割的对象/Vector.py)### 9.7 python的私有属性和‘受保护’的属性* python不能像java那样使用private修饰符创建私有属性，但是python有个简单的机制，能避免子类意外覆盖私有属性。 `__name`* python会把属性名存入实例 `__dict__`属性中，而且会在前面加上一个下划线和类名，因此，对Dog的__mode 是这样 `_Dog_mode`。* python解释器不会对使用单个下划线的属性名做特殊处理，不过这是很多python程序员严格遵守的约定。### 9.8 使用 `__slots__`类属性节省空间* 一个特殊的属性，它会影响对象的内部存储，对内存用量可能也有重大影响，不过对对象的公开接口没什么影响，* 默认情况下，python在各个实例中名为 `__dict__`的字典里存储实例属性，为了提升底层的散列表提升访问速度，字典会消耗大量内存，如果要处理数量百万属性不多的实例，通过 `__slots__`类属性，能节省大量内存，方法是让解释器在元组中存储实例属性，而不是字典。* 继承子超类的 `__slots__`属性没有效果，python只会使用各个类中定义的 `__slots__`属性。* 定义 `__slots__`的方法是，创建一个类属性，使用 `__slots__`这个名字，并把它的值设置为字符串构成的可迭代对象，其中各个元素表示各个实例属性。```class Vector():    __slots = ('x', 'y')        typecode = 'd'```* 在类中定义 `__slots__`属性的目的是告诉解释器，这个类中所有实例属性都在这儿了。* 在定义 `__slots__`属性后，实例不能再有 `__slots__`中所列名称之外的其他属性。这只是一个副作用，不是 `__slots__`存在真在原因，不要使用 `__slots__`属性禁止类的用户新增实例属性，`__slots__`是用于优化，不是为了约束程序员。* `__weakref__`属性需要注意：    * 为了支持弱引用，必须有这个属性，    * 用户定义的类中默认有这个属性，但如果使用了 `__slots__`，就没有这个属性了，如果需要，需要显示加上。#### `__slots__`的问题：* 每个子类都需要定义 `__slots__`属性，因为解释器会忽略继承的这个属性* 实例只拥有 `__slots__`列出的属性，除非把 `__dict__`加入该属性，但这样就无效了* 如果不把 `__weakref__`加入 `__slots__`属性，实例就不能作为弱引用的目标。### 9.9 覆盖类属性* python有个独特的特性：类属性可用于实例属性提供默认值。* 如果为不存在的实例属性赋值，会新建实例属性，加入我们为typecode实例属性复制，那么同名类属性不受影响，然后，自此之后，实例读取的self.typecode是实例属性，也就是同名类属性被覆盖了，借助这一特性，可以为各个实例的typecode属性定制不同的值。### 9.10 本章小结* 所有用于获取字符串和字节序列表示形式的方法： `__repr__`,`__str__`,`__format__`和`__bytes__`* 把对象转换成数字的几个方法： `__abs__`, `__bool__`, `__hash__`* 用于测试字节序列转换和支持散列的 `__eq__`运算符